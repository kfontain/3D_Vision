\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[frenchb]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{minted} %compiler avec la commande -shell-escape
\usepackage{graphicx}

%% Todo List
\usepackage{enumitem,amssymb}
\newlist{todolist}{itemize}{2}
\setlist[todolist]{label=$\square$}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\done}{\rlap{$\square$}{\raisebox{2pt}{\large\hspace{1pt}\cmark}}%
\hspace{-2.5pt}}
\newcommand{\wontfix}{\rlap{$\square$}{\large\hspace{1pt}\xmark}}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\setlength{\parskip}{.5em}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

%-------------------------------------------------------------------------------
% TITLE PAGE
%-------------------------------------------------------------------------------

\title
{
	\LARGE{Projet Technologique}
	\HRule \\ [0.5cm]
	\LARGE \textbf{\uppercase{Vision Stéréoscopique}}
	\HRule \\ [0.5cm]
}

\author{Geoffrey MEILHAN \\ Mohamed ALAMI \\ Kenji FONTAINE}

\begin{document}

\null  % Empty line
\nointerlineskip  % No skip for prev line
\vfill
\let\snewpage \newpage
\let\newpage \relax
\maketitle
\let \newpage \snewpage
\vfill
\break % page break

%-------------------------------------------------------------------------------
% Table of Contents
%-------------------------------------------------------------------------------

\tableofcontents
\newpage

%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\section{Description du projet}
La stéréoscopie est un ensemble de techniques visant à créer ou améliorer la
perception de relief à partir de deux images planes.

Le projet consiste à développer un module permettant d'évaluer une distance à
partir de deux images planes en entrée. Ce projet prendra la forme d'une implémentation
du module sur un système mobile à roues. L'objectif final étant de concevoir un robot
suiveur, capable de suivre une personne à une distance donnée.

%-------------------------------------------------------------------------------
% Domaine
%-------------------------------------------------------------------------------

\section{Domaine : Vision stéréoscopique}

Aujourd'hui devenu peu coûteux et peu encombrant, les systèmes de vision
stéréoscopiques sont de plus en plus répandus. \\
On trouve de nombreux domaines d'application dont les suivants :
\begin{itemize}
	\item Système de freinage automatique chez les voitures (Toyota par exemple).
	\item Détection d'obstacle chez les voitures autonomes.
	\item Reconnaissance d'objets chez les robots.
	\item La réalité virtuelle
\end{itemize}

%-------------------------------------------------------------------------------
% Cahier des charges
%-------------------------------------------------------------------------------

\section{Cahier des charges}

And got so far

\subsection{Besoins fonctionnels}

\subsubsection{QT/OpenCV}
-split une image
-detection de bords
-carte de disparitée
-carte de profondeur
-convertir une Qimage en cvMat et inverse
-avoir une fenetre permettant de modifier une image avec les differentes fonctionnalitées implementées

\subsubsection{Unity}

-créer un environnement proche de la réalitée
-Déplacer Bob dans l'environnement
-Obtenir des images stereoscopiques proche du cas reel


\subsubsection{Robot}
-Traiter une image en carte de disparitée
-ET C EST TOUT PARCEQU ON PEUT RIEN FAIRE SUR LE ROBOT

\subsection{Besoins non fonctionnels}

\subsubsection{QT/Opencv}
-robuste?
-rapide?

\subsubsection{Unity}


\subsubsection{Robot}
-Traiter x images/sec pour reduire les erreurs possibles
-


%-------------------------------------------------------------------------------
% Architecture du code QT CV
%-------------------------------------------------------------------------------

\section{Architecture du code : partie QT et OpenCV}

%%%%% CONVERT %%%%%
\subsubsection*{convert.cpp convert.h}

Ces fichiers permettent de convertir des images stockées sous le format d'openCV
(cv::Mat) en image sous format QT(QImage) et inversement. Il existe deux fonctions
principales : \textbf{mat2QImage} et \textbf{qImage2Mat}.

%%%%% EDIT %%%%%
\subsubsection*{edit.cpp edit.h}

Ces fichiers forment le "core" de notre module. Sont incluent la plupart des
algorithmes utilisés lors des calculs de carte de disparité ou de profondeur,
de détection de bords, de détections de points d'intérêt, etc...


\textbf{split :} Cette fonction permet de séparer verticalement une image en
entrée, en deux images de même taille. Elle prend en entrée une image de type
QImage. Cette QImage sera coupée en deux et chaque partie ainsi obtenue sera
respectivement stockée dans les cv::Mat dont les adresse sont données en paramètres.


\textbf{sobel :} Cette fonction permet de détecter les bords d'une image. Elle
prend en entrée une image de type cv::Mat. la fonction va effectuer sur l'image
source une détection de bords, puis stockera le résultat ainsi obtenu dans une
autre image cv::Mat dont l'adresse est donnée en tant que paramètre.


\textbf{surf et surfmatch :} Ces deux fonctions permettent d'effectuer une détection
de points d'intérêts. La fonction \textbf{surf} prend une seule image de type
cv::Mat en entrée. Elle va détecter les points d'intérêt sur l'image en entrée puis
les mettre en valeur. Le résultat obtenu sera stockée dans une autre image cv::Mat
dont l'adresse est donnée en tant que paramètre.


La fonction \textbf{surfMath} fait la même chose mais avec 2 images en entrée,
toujours de type cv::Mat. Elle va, en plus de la détection de points d'intérêts,
effectuer une mise en correspondance des points d'intérêts entre eux. Le résultat
obtenu sera stocké dans une cv::Mat de destination dont l'adresse est en paramètre
de la fonction.


\textbf{dispMap :} Cette fonction permet de calculer une carte de disparité à
partir de deux images cv::Mat en entrée. Elle fait appel à l'algorithme
\textbf{StereoBM} de la bibliothèque \textbf{OpenCV}. La carte de disparité ainsi
obtenue est stockée dans une image cv::Mat dont l'adresse est donnée en paramètre.

%%%%% MAIN %%%%%
\subsubsection*{main.cpp}

Il s'agit du code exécuté lors du lancement du programme. On distingue 2 parties.
Une première partie avec GUI correspond au code généré par défaut par QT.
Elle permet de lancer le programme avec l'interface graphique.

\begin{minted}{cpp}
int main(int argc, char *argv[])
{
	QApplication a(argc, argv);
	MainWindow w;
	w.show();

	return a.exec();
}
\end{minted}

Une deuxième partie permet d'executer des parties différentes du code en fonction de l'argument rentré lors de l'appel du programme. Si l'appel au programme se fait par la commande:
\begin{minted}{bash}
$ ./projet 0
\end{minted}
Alors le programme va traiter toutes les images dans les sous-dossiers écrits en dur dans le code, dans ce cas précis il récupère les images dans le dossier source/cam et écrit dans le dossier result/cam avec l'appel suivant:
\begin{minted}{cpp}
for (int j = 0 ; j < 3 ; j++) {
  for (int i = 0 ; i < 5 ; i++) {
    std::ostringstream ossI, ossO;
    ossI << "source/cam" << j << "-dist" << i << ".png"; //path fichier entrant
    ossO << "result/cam" << j << "-dist" << i << ".png"; //path fichier sortant
\end{minted}
Le nombre d'images traitée est i*j et est rentré en dur dans le code. Cette partie a été écrite pour faciliter le traitement d'un grand nombre d'images, afin de tester les cartes de profondeur sur diverses situations.

Une troisième partie très similaire à celle décrite plus haut, à la différence pret que les images en entrée sont au nombre de deux et ont déjà était split. L'implémentation est la même avec la quantitée d'images écrite en dur dans le code, tout comme les dossiers contenant les images. L'appel se fait par:
\begin{minted}{bash}
$ ./projet 1
\end{minted}

Enfin un dernier appel au programme peut être fait permettant de tester plusieurs valeurs de SAD  et de ... pour un image rentré dans le code. Celà nous a permis de faire des tests sur les valeurs optimales de StereoBM sur une certaine image, avant notre implémentation des trackbars. L'appel se fait par:
\begin{minted}{bash}
$ ./projet 2
\end{minted}



%-------------------------------------------------------------------------------
% Architecture du code Unity
%-------------------------------------------------------------------------------

\section{Architecture du code : partie Unity}

But in the end

%-------------------------------------------------------------------------------
% Tests
%-------------------------------------------------------------------------------

\section{Tests}

- ouvrir une image
- détection de bords
- split
- depth/disp map
- unity (scripts)
-

I didn't went to Japan

Nous n'avons pas écrit de fonction permettant de tester les différentes fonctionnalitées de notre programme, même si on peut assimiler les différents appel à notre programme avec les arguments "0", "1" ou "2" comme des tests pour les fonctionnalitées suivantes:
\begin{itemize}
\item Ouvrir une image
\item Convertir une Qimage en cvMat et l'opération inverse
\item Split une image en deux images de même résolution afin de les traiter
\item Obtenir une carte de disparitée
\item Ouvrir une nouvelle fenetre

\end{itemize}


Nous avons cependant testé toutes les fonctionnalitées que notre programme est censé contenir dans le cahier des charges.

%-------------------------------------------------------------------------------
% Problèmes rencontrés
%-------------------------------------------------------------------------------

\section{Problèmes rencontrés}


\subsection*{Installation OpenCV}

Lors des premières séances, nous avons eu des difficultés a installer OpenCV. En effet, utilisant les trois OS majeures(Windows, Mac, Linux), la procédure d'installaion n'était pas la même et nous n'avons pas pu nous aider les uns les autres facilement. Ceci a retardé un peu l'implémentation des fonctions OpenCV, et nous avons même abandonné l'installation sous Windows.

\subsection*{Carte de disparité}

Afin de traiter la carte de disparitée, nous avons dans un premier temps utiliser l'algorithme StereoBM. L'appel à celui-ci sur les images tests fournis par l'enseignant nous retournait un résultat satisfaisant lorsque nous n'utilisions aucun paramètre. Nous avons donc garder cette implémentation naive(pas sur pour cet adjectif) de StereoBM.

Lorsque nous en avons du traiter les images issues du robot, les valeurs par défaut de cet algorithme ne nous donnait pas de résultat concluant. Nous avons donc eu besoin d'implémenter une variation des paramètre de StereoBM dans notre code, afin de mieux controller le résultat. Après avoir essayer pendant plusieurs séances d'améliorer les cartes de profondeur avec cette méthode, nous avons abandonner au profit de l'utilisation de SteroSGBM. Ces deux algorithmes étant similaire dans leur implémentation, nous n'avons pas eu besoin de beaucoup de temps pour adapter notre programme. Nous avons très rapidement obtenu un meilleur résultat avec beaucoup moins d'effort.

\subsection*{Conversion d'images}

Notre conversion d'images a encore des probèmes de source inconnues. En effet, lors de l'appel du split depuis l'interface graphique, les images ne sont pas traités et la fonction split affiche deux fois l'image de gauche. Cependant le split est le seul moment ou nous avont remarqué ce comportement.

%-------------------------------------------------------------------------------
% Conclusion
%-------------------------------------------------------------------------------

\section{Conclusion}

Grace a ce projet nous avons pu en apprendre plus sur un domaine qui nous était peu connu en la reconaissance visuelle, ainsi qu'ameliorer nos connaissances en C++.

%-------------------------------------------------------------------------------
% In the end
%-------------------------------------------------------------------------------

\end{document}
